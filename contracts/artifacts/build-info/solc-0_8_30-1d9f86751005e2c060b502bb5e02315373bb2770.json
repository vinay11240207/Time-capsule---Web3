{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-1d9f86751005e2c060b502bb5e02315373bb2770",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/TimeCapsule.sol": "project/contracts/TimeCapsule.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/TimeCapsule.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\n/**\n * @title TimeCapsule\n * @dev A smart contract for creating time-locked capsules with encrypted content\n * @author Shourya Sharma\n */\ncontract TimeCapsule {\n    // Enums\n    enum CapsuleType { RAW_TEXT, HASH_ONLY, ENCRYPTED }\n    enum CapsuleStatus { LOCKED, UNLOCKED, REVEALED }\n\n    // Structs\n    struct CapsuleMeta {\n        address owner;\n        uint64 createdAt;\n        uint64 unlockTime;\n        CapsuleType capsuleType;\n        CapsuleStatus status;\n        bytes32 contentHash;\n        string contentRef; // IPFS CID or similar\n        string[] recipients; // Optional recipient addresses/ENS\n        bool isPublic;\n    }\n\n    // State variables\n    uint256 private _capsuleCounter;\n    mapping(uint256 => CapsuleMeta) private _capsules;\n    mapping(address => uint256[]) private _userCapsules;\n    \n    // Constants\n    uint64 public constant MIN_LOCK_DURATION = 1 days;\n    uint64 public constant MAX_LOCK_DURATION = 10 * 365 days; // 10 years\n    uint256 public constant MAX_CONTENT_SIZE = 32 * 1024; // 32KB for raw text\n    \n    // Optional protocol fee\n    uint256 public protocolFee = 0.001 ether;\n    address public treasury;\n\n    // Events\n    event CapsuleCreated(\n        uint256 indexed capsuleId,\n        address indexed owner,\n        uint64 unlockTime,\n        CapsuleType capsuleType,\n        bytes32 contentHash\n    );\n    \n    event CapsuleRevealed(\n        uint256 indexed capsuleId,\n        address indexed revealer,\n        string finalContentRef\n    );\n    \n    event CapsuleUnlocked(\n        uint256 indexed capsuleId,\n        address indexed unlocker\n    );\n\n    // Custom errors\n    error InvalidUnlockTime();\n    error InsufficientFee();\n    error NotOwner();\n    error CapsuleNotFound();\n    error CapsuleStillLocked();\n    error CapsuleAlreadyRevealed();\n    error ContentTooLarge();\n    error HashMismatch();\n    error UnauthorizedAccess();\n\n    // Modifiers\n    modifier validCapsule(uint256 capsuleId) {\n        if (capsuleId == 0 || capsuleId > _capsuleCounter) {\n            revert CapsuleNotFound();\n        }\n        _;\n    }\n\n    modifier onlyOwner(uint256 capsuleId) {\n        if (_capsules[capsuleId].owner != msg.sender) {\n            revert NotOwner();\n        }\n        _;\n    }\n\n    modifier onlyUnlocked(uint256 capsuleId) {\n        if (block.timestamp < _capsules[capsuleId].unlockTime) {\n            revert CapsuleStillLocked();\n        }\n        _;\n    }\n\n    constructor(address _treasury) {\n        treasury = _treasury;\n    }\n\n    /**\n     * @dev Create a new time capsule\n     * @param capsuleType Type of content (RAW_TEXT, HASH_ONLY, ENCRYPTED)\n     * @param contentHash Keccak256 hash of the content\n     * @param contentRef Optional IPFS CID or external reference\n     * @param unlockTime Timestamp when capsule can be accessed\n     * @param recipients Optional list of recipient addresses\n     * @param isPublic Whether capsule is publicly viewable when unlocked\n     */\n    function createCapsule(\n        CapsuleType capsuleType,\n        bytes32 contentHash,\n        string calldata contentRef,\n        uint64 unlockTime,\n        string[] calldata recipients,\n        bool isPublic\n    ) external payable returns (uint256 capsuleId) {\n        // Validate unlock time\n        uint64 currentTime = uint64(block.timestamp);\n        if (unlockTime <= currentTime + MIN_LOCK_DURATION || \n            unlockTime > currentTime + MAX_LOCK_DURATION) {\n            revert InvalidUnlockTime();\n        }\n\n        // Check protocol fee\n        if (msg.value < protocolFee) {\n            revert InsufficientFee();\n        }\n\n        // Increment counter and create capsule\n        capsuleId = ++_capsuleCounter;\n        \n        _capsules[capsuleId] = CapsuleMeta({\n            owner: msg.sender,\n            createdAt: currentTime,\n            unlockTime: unlockTime,\n            capsuleType: capsuleType,\n            status: CapsuleStatus.LOCKED,\n            contentHash: contentHash,\n            contentRef: contentRef,\n            recipients: recipients,\n            isPublic: isPublic\n        });\n\n        // Add to user's capsule list\n        _userCapsules[msg.sender].push(capsuleId);\n\n        // Transfer protocol fee to treasury\n        if (protocolFee > 0 && treasury != address(0)) {\n            payable(treasury).transfer(protocolFee);\n        }\n\n        // Refund excess payment\n        if (msg.value > protocolFee) {\n            payable(msg.sender).transfer(msg.value - protocolFee);\n        }\n\n        emit CapsuleCreated(capsuleId, msg.sender, unlockTime, capsuleType, contentHash);\n    }\n\n    /**\n     * @dev Reveal the content of an encrypted or hash-only capsule\n     * @param capsuleId The ID of the capsule to reveal\n     * @param plaintextOrKey The original content or decryption key\n     * @param finalContentRef Optional final content reference after reveal\n     */\n    function revealCapsule(\n        uint256 capsuleId,\n        bytes calldata plaintextOrKey,\n        string calldata finalContentRef\n    ) external validCapsule(capsuleId) onlyUnlocked(capsuleId) {\n        CapsuleMeta storage capsule = _capsules[capsuleId];\n        \n        // Check authorization\n        if (!_canAccessCapsule(capsuleId, msg.sender)) {\n            revert UnauthorizedAccess();\n        }\n\n        if (capsule.status == CapsuleStatus.REVEALED) {\n            revert CapsuleAlreadyRevealed();\n        }\n\n        // Verify content hash\n        bytes32 computedHash = keccak256(plaintextOrKey);\n        if (computedHash != capsule.contentHash) {\n            revert HashMismatch();\n        }\n\n        // Update capsule status\n        capsule.status = CapsuleStatus.REVEALED;\n        if (bytes(finalContentRef).length > 0) {\n            capsule.contentRef = finalContentRef;\n        }\n\n        emit CapsuleRevealed(capsuleId, msg.sender, finalContentRef);\n    }\n\n    /**\n     * @dev Unlock a capsule (mark as accessible)\n     * @param capsuleId The ID of the capsule to unlock\n     */\n    function unlockCapsule(uint256 capsuleId) \n        external \n        validCapsule(capsuleId) \n        onlyUnlocked(capsuleId) \n    {\n        CapsuleMeta storage capsule = _capsules[capsuleId];\n        \n        // Check authorization\n        if (!_canAccessCapsule(capsuleId, msg.sender)) {\n            revert UnauthorizedAccess();\n        }\n\n        if (capsule.status == CapsuleStatus.LOCKED) {\n            capsule.status = CapsuleStatus.UNLOCKED;\n            emit CapsuleUnlocked(capsuleId, msg.sender);\n        }\n    }\n\n    /**\n     * @dev Get capsule metadata\n     * @param capsuleId The ID of the capsule\n     */\n    function getCapsule(uint256 capsuleId) \n        external \n        view \n        validCapsule(capsuleId) \n        returns (CapsuleMeta memory) \n    {\n        return _capsules[capsuleId];\n    }\n\n    /**\n     * @dev Get all capsule IDs for a user\n     * @param user The address of the user\n     */\n    function getUserCapsules(address user) external view returns (uint256[] memory) {\n        return _userCapsules[user];\n    }\n\n    /**\n     * @dev Get total number of capsules created\n     */\n    function totalCapsules() external view returns (uint256) {\n        return _capsuleCounter;\n    }\n\n    /**\n     * @dev Check if a user can access a capsule\n     * @param capsuleId The ID of the capsule\n     * @param user The address to check\n     */\n    function canAccessCapsule(uint256 capsuleId, address user) \n        external \n        view \n        validCapsule(capsuleId) \n        returns (bool) \n    {\n        return _canAccessCapsule(capsuleId, user);\n    }\n\n    /**\n     * @dev Internal function to check capsule access permissions\n     */\n    function _canAccessCapsule(uint256 capsuleId, address user) \n        internal \n        view \n        returns (bool) \n    {\n        CapsuleMeta storage capsule = _capsules[capsuleId];\n        \n        // Owner can always access\n        if (capsule.owner == user) {\n            return true;\n        }\n\n        // Check if user is in recipients list (basic string comparison)\n        // Note: This is a simple implementation. In production, you might want\n        // to use address comparison or ENS resolution\n        string memory userStr = _addressToString(user);\n        for (uint i = 0; i < capsule.recipients.length; i++) {\n            if (_compareStrings(capsule.recipients[i], userStr)) {\n                return true;\n            }\n        }\n\n        // Public capsules can be accessed by anyone when unlocked\n        if (capsule.isPublic && block.timestamp >= capsule.unlockTime) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Convert address to string\n     */\n    function _addressToString(address addr) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(42);\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint i = 0; i < 20; i++) {\n            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\n            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\n        }\n        return string(str);\n    }\n\n    /**\n     * @dev Compare two strings\n     */\n    function _compareStrings(string memory a, string memory b) \n        internal \n        pure \n        returns (bool) \n    {\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n    }\n\n    /**\n     * @dev Update protocol fee (only owner)\n     */\n    function setProtocolFee(uint256 newFee) external {\n        require(msg.sender == treasury, \"Only treasury can update fee\");\n        protocolFee = newFee;\n    }\n\n    /**\n     * @dev Update treasury address (only current treasury)\n     */\n    function setTreasury(address newTreasury) external {\n        require(msg.sender == treasury, \"Only treasury can update address\");\n        treasury = newTreasury;\n    }\n}"
      }
    }
  }
}